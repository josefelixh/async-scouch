<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Async-scouch by josefelixh</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Async-scouch</h1>
        <h2>Asynchronoush non-blocking BigCouch/Cloudant client.</h2>
        <h2>Async-scouch is a BigCouch/Cloudant client library. It based on top of netty, ning asynchronous http client and the super cool play-json libraries based on jerkson/jackson. So far is targets scala, but the intention is to make it work for java as well.</h2>

        <section id="downloads">
          <a href="https://github.com/josefelixh/async-scouch/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/josefelixh/async-scouch/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/josefelixh/async-scouch" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>Usage (Scala)</h3>
        <h4>Basic CRUD operations</h4>

        <p>First you need some stuff to persist.</p>

<pre><code>
case class Role(name: String, permissions: Int)
case class Profile(id: String, level: Int, roles: Seq[Role])

val role = Role("admin", 777)
val profile = Profile("badger", 0, Vector(role))
</code></pre>

          <p>Then configure the client</p>
<pre><code>
val credentials = Some(("username", "password"))
val couchConfig = CouchConfig("https://couchinstance.com:port", "dbname", credentials)

implicit val executionContext = ExecutionContext.Implicits.global
implicit val couch = Couch(couchConfig)
</code></pre>

          <p>Provide a way to serialise/deserialise your objects to json</p>
<pre><code>
implicit val roleFormat = Json.format[Role]
implicit val profileFormat = Json.format[Profile]
</code></pre>

          <p>Then you can just use CouchDocument to do CRUD operations with your objects.</p>
<pre><code>
val future = for {
  createdNoId <- CouchDocument(profile).create
  created <- CouchDocument("PROFILE_ID", profile).create
  docId = Id[Profile](createdNoId.id.get)
  retreived <- docId.retrieve
  updated <- createdNoId.update(current => current.copy(level = 1))
  updateRetreived <- docId.retrieve
  deleteResponse <- updated.delete
  deleteResponse2 <- created.delete
} yield {
  println(s"CREATED : $createdNoId")
  println(s"CREATED : $created")
  println(s"RETREIVED : $retreived")
  println(s"UPDATED : $updated")
  println(s"RETREIVED : $updateRetreived")
  println(s"DELETED : ${deleteResponse.json}")
  println(s"DELETED : ${deleteResponse2.json}")
}

future.onComplete {
  case Success(x) => println("Easy!!!")
  case Failure(t) => println("An error has occured: " + t.getMessage)
}
</code></pre>

        <p>In order to see some results it is needed to wait for the future, but this is something you might not want to do in your application.</p>

<code><pre>
Await.result(future, 10 seconds)
</pre></code>
<p>This automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here using GitHub Flavored Markdown, select a template crafted by a designer, and publish. After your page is generated, you can check out the new branch:</p>

      </section>
    </div>

    
  </body>
</html>